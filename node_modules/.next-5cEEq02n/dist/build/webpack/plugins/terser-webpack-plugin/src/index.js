t4_float4_float4(float4 x0, float4 x1, float4 x2, float4 x3)
{
    return float4x4(x0, x1, x2, x3);
}
// Uniforms

uniform float4 _sk_RTAdjust : register(c0);
uniform float3x3 _umatrix_S1_c0_c0 : register(c1);
#ifdef ANGLE_ENABLE_LOOP_FLATTEN
#define LOOP [loop]
#define FLATTEN [flatten]
#else
#define LOOP
#define FLATTEN
#endif

#define ATOMIC_COUNTER_ARRAY_STRIDE 4

// Attributes
static float4 _radii_selector = {0, 0, 0, 0};
static float4 _corner_and_radius_outsets = {0, 0, 0, 0};
static float4 _aa_bloat_and_coverage = {0, 0, 0, 0};
static float4 _radii_x = {0, 0, 0, 0};
static float4 _radii_y = {0, 0, 0, 0};
static float4 _skew = {0, 0, 0, 0};
static float4 _translate_and_localrotate = {0, 0, 0, 0};
static float4 _localrect = {0, 0, 0, 0};
static float4 _color = {0, 0, 0, 0};

static float4 gl_Position = float4(0, 0, 0, 0);

// Varyings
static noperspective float4 _vcolor_S0 = {0, 0, 0, 0};
static noperspective float2 _varccoord_S0 = {0, 0};
static noperspective float2 _vTransformedCoords_4_S0 = {0, 0};

cbuffer DriverConstants : register(b1)
{
    float4 dx_ViewAdjust : packoffset(c1);
    float2 dx_ViewCoords : packoffset(c2);
    float2 dx_ViewScale  : packoffset(c3);
    float clipControlOrigin : packoffset(c3.z);
    float clipControlZeroToOne : packoffset(c3.w);
};

@@ VERTEX ATTRIBUTES @@

VS_OUTPUT generateOutput(VS_INPUT input)
{
    VS_OUTPUT output;
    output.gl_Position = gl_Position;
    output.dx_Position.x = gl_Position.x;
    output.dx_Position.y = clipControlOrigin * gl_Position.y;
    if (clipControlZeroToOne)
    {
        output.dx_Position.z = gl_Position.z;
    } else {
        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;
    }
    output.dx_Position.w = gl_Position.w;
    output.v0 = _vcolor_S0;
    output.v1 = _varccoord_S0;
    output.v2 = _vTransformedCoords_4_S0;

    return output;
}

VS_OUTPUT main(VS_INPUT input){
    initAttributes(input);

(_vcolor_S0 = _color);
float _aa_bloat_multiplier5640 = {1.0};
float2 _corner5641 = _corner_and_radius_outsets.xy;
float2 _radius_outset5642 = _corner_and_radius_outsets.zw;
float2 _aa_bloat_direction5643 = _aa_bloat_and_coverage.xy;
float _is_linear_coverage5644 = _aa_bloat_and_coverage.w;
float2 _pixellength5645 = rsqrt(vec2_ctor(dot(_skew.xz, _skew.xz), dot(_skew.yw, _skew.yw)));
float4 _normalized_axis_dirs5646 = (_skew * _pixellength5645.xyxy);
float2 _axiswidths5647 = (abs(_normalized_axis_dirs5646.xy) + abs(_normalized_axis_dirs5646.zw));
float2 _aa_bloatradius5648 = ((_axiswidths5647 * _pixellength5645) * 0.5);
float4 _radii_and_neighbors5649 = mul(_radii_selector, transpose(mat4_ctor_float4_float4_float4_float4(_radii_x, _radii_y, _radii_x.yxwz, _radii_y.wzyx)));
float2 _radii5650 = _radii_and_neighbors5649.xy;
float2 _neighbor_radii5651 = _radii_and_neighbors5649.zw;
float _coverage_multiplier5652 = {1.0};
if (any((_aa_bloatradius5648 > float2(1.0, 1.0))))
{
(_corner5641 = (max(abs(_corner5641), _aa_bloatradius5648) * sign(_corner5641)));
(_coverage_multiplier5652 = (1.0 / (max(_aa_bloatradius5648.x, 1.0) * max(_aa_bloatradius5648.y, 1.0))));
(_radii5650 = float2(0.0, 0.0));
}
float _coverage5653 = _aa_bloat_and_coverage.z;
if (any((_radii5650 < (_aa_bloatradius5648 * 1.5))))
{
(_radii5650 = float2(0.0, 0.0));
(_aa_bloat_direction5643 = sign(_corner5641));
if ((_coverage5653 > 0.5))
{
(_aa_bloat_direction5643 = (-_aa_bloat_direction5643));
}
(_is_linear_coverage5644 = 1.0);
}
else
{
(_radii5650 = clamp(_radii5650, (_pixellength5645 * 1.5), (2.0 - (_pixellength5645 * 1.5))));
(_neighbor_radii5651 = clamp(_neighbor_radii5651, (_pixellength5645 * 1.5), (2.0 - (_pixellength5645 * 1.5))));
float2 _spacing5654 = ((2.0 - _radii5650) - _neighbor_radii5651);
float2 _extra_pad5655 = max(((_pixellength5645 * 0.0625) - _spacing5654), float2(0.0, 0.0));
(_radii5650 -= (_extra_pad5655 * 0.5));
}
float2 _aa_outset5656 = ((_aa_bloat_direction5643 * _aa_bloatradius5648) * _aa_bloat_multiplier5640);
float2 _vertexpos5657 = ((_corner5641 + (_radius_outset5642 * _radii5650)) + _aa_outset5656);
if ((_coverage5653 > 0.5))
{
if (((_aa_bloat_direces) {
                    console.log(name);
                    return false;
                }
                // don't minify _middleware as it can break in some cases
                // and doesn't provide too much of a benefit as it's server-side
                if (name.match(/(edge-runtime-webpack\.js|edge-chunks|middleware\.js$)/)) {
                    return false;
                }
                const { info  } = res;
                // Skip double minimize assets from child compilation
                if (info.minimized) {
                    return false;
                }
                return true;
            }).map(async (name)=>{
                const { info , source  } = compilation.getAsset(name);
                const eTag = cache.getLazyHashedEtag(source);
                const output = await cache.getPromise(name, eTag);
                if (!output) {
                    numberOfAssetsForMinify += 1;
                }
                if (debugMinify && debugMinify === "1") {
                    console.dir({
                        name,
                        source: source.source().toString()
                    }, {
                        breakLength: Infinity,
                        maxStringLength: Infinity
                    });
                }
                return {
                    name,
                    info,
                    inputSource: source,
                    output,
                    eTag
                };
            }));
            const numberOfWorkers = Math.min(numberOfAssetsForMinify, optimizeOptions.availableNumberOfCores);
            let initializedWorker;
            // eslint-disable-next-line consistent-return
            const getWorker = ()=>{
                if (this.options.swcMinify) {
                    return {
                        minify: async (options)=>{
                            const result = await require("../../../../swc").minify(options.input, {
                                ...options.inputSourceMap ? {
                                    sourceMap: {
                                        content: JSON.stringify(options.inputSourceMap)
                                    }
                                } : {},
                                compress: true,
                                mangle: true
                            });
                            return result;
                        }
                    };
                }
                if (initializedWorker) {
                    return initializedWorker;
                }
                initializedWorker = new _jestworker.Worker(_path.join(__dirname, "./minify.js"), {
                    numWorkers: numberOfWorkers,
                    enableWorkerThreads: true
                });
                initializedWorker.getStdout().pipe(process.stdout);
                initializedWorker.getStderr().pipe(process.stderr);
                return initializedWorker;
            };
            const limit = (0, _plimit.default)(// When using the SWC minifier the limit will be handled by Node.js
            this.options.swcMinify ? Infinity : numberOfAssetsForMinify > 0 ? numberOfWorkers : Infinity);
            const scheduledTasks = [];
            for (const asset of assetsForMinify){
                scheduledTasks.push(limit(async ()=>{
                    const { name , inputSource , info , eTag  } = asset;
                    let { output  } = asset;
                    const minifySpan = terserSpan.traceChild("minify-js");
                    minifySpan.setAttribute("name", name);
                    minifySpan.setAttribute("cache", typeof output === "undefined" ? "MISS" : "HIT");
                    return minifySpan.traceAsyncFn(async ()=>{
                        if (!output) {
                            const { source: sourceFromInputSource , map: inputSourceMap  } = inputSource.sourceAndMap();
                            const input = Buffer.isBuffer(sourceFromInputSource) ? sourceFromInputSource.toString() : sourceFromInputSource;
                            const options = {
                                name,
                                input,
                                inputSourceMap,
                                terserOptions: {
                                    ...this.options.terserOptions
                                }
                            };
                            if (typeof options.terserOptions.module === "undefined") {
                                if (typeof info.javascriptModule !== "undefined") {
                                    options.terserOptions.module = info.javascriptModule;
                                } else if (/\.mjs(\?.*)?$/i.test(name)) {
                                    options.terserOptions.module = true;
                                } else if (/\.cjs(\?.*)?$/i.test(name)) {
                                    options.terserOptions.module = false;
                                }
                            }
                            try {
                                output = await getWorker().minify(options);
                            } catch (error) {
                                compilation.errors.push(buildError(error, name));
                                return;
                            }
                            if (output.map) {
                                output.source = new SourceMapSource(output.code, name, output.map, input, inputSourceMap, true);
                            } else {
                                output.source = new RawSource(output.code);
                            }
                            await cache.storePromise(name, eTag, {
                                source: output.source
                            });
                        }
                        const newInfo = {
                            minimized: true
                        };
                        const { source  } = output;
                        compilation.updateAsset(name, source, newInfo);
                    });
                }));
            }
            await Promise.all(scheduledTasks);
            if (initializedWorker) {
                await initializedWorker.end();
            }
        });
    }
    apply(compiler) {
        var _compiler_webpack;
        const { SourceMapSource , RawSource  } = (compiler == null ? void 0 : (_compiler_webpack = compiler.webpack) == null ? void 0 : _compiler_webpack.sources) || _webpack.sources;
        const { output  } = compiler.options;
        if (typeof this.options.terserOptions.ecma === "undefined") {
            this.options.terserOptions.ecma = getEcmaVersion(output.environment || {});
        }
        const pluginName = this.constructor.name;
        const availableNumberOfCores = this.options.parallel;
        compiler.hooks.thisCompilation.tap(pluginName, (compilation)=>{
            const cache = compilation.getCache("TerserWebpackPlugin");
            const handleHashForChunk = (hash, _chunk)=>{
                // increment 'c' to invalidate cache
                hash.update("c");
            };
            const JSModulesHooks = _webpack.webpack.javascript.JavascriptModulesPlugin.getCompilationHooks(compilation);
            JSModulesHooks.chunkHash.tap(pluginName, (chunk, hash)=>{
                if (!chunk.hasRuntime()) return;
                return handleHashForChunk(hash, chunk);
            });
            compilation.hooks.processAssets.tapPromise({
                name: pluginName,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE
            }, (assets)=>this.optimize(compiler, compilation, assets, {
                    availableNumberOfCores
                }, cache, {
                    SourceMapSource,
                    RawSource
                }));
            compilation.hooks.statsPrinter.tap(pluginName, (stats)=>{
                stats.hooks.print.for("asset.info.minimized").tap("terser-webpack-plugin", (minimized, { green , formatFlag  })=>// eslint-disable-next-line no-undefined
                    minimized ? green(formatFlag("minimized")) : undefined);
            });
        });
    }
}

//# sourceMappingURL=index.js.map