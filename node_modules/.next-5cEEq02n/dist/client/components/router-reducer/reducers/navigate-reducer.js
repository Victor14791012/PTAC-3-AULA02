"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleExternalUrl: null,
    navigateReducer: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleExternalUrl: function() {
        return handleExternalUrl;
    },
    navigateReducer: function() {
        return navigateReducer;
    }
});
const _approutercontext = require("../../../../shared/lib/app-router-context");
const _fetchserverresponse = require("../fetch-server-response");
const _createrecordfromthenable = require("../create-record-from-thenable");
const _readrecordvalue = require("../read-record-value");
const _createhreffromurl = require("../create-href-from-url");
const _invalidatecachebelowflightsegmentpath = require("../invalidate-cache-below-flight-segmentpath");
const _fillcachewithdataproperty = require("../fill-cache-with-data-property");
const _createoptimistictree = require("../create-optimistic-tree");
const _applyrouterstatepatchtotree = require("../apply-router-state-patch-to-tree");
const _shouldhardnavigate = require("../should-hard-navigate");
const _isnavigatingtonewrootlayout = require("../is-navigating-to-new-root-layout");
const _routerreducertypes = require("../router-reducer-types");
const _handlemutable = require("../handle-mutable");
const _applyflightdata = require("../apply-flight-data");
const _getprefetchcacheentrystatus = require("../get-prefetch-cache-entry-status");
const _pruneprefetchcache = require("./prune-prefetch-cache");
function handleExternalUrl(state, mutable, url, pendingPush) {
    mutable.previousTree = state.tree;
    mutable.mpaNavigation = true;
    mutable.canonicalUrl = url;
    mutable.pendingPush = pendingPush;
    mutable.scrollableSegments = undefined;
    return (0, _handlemutable.handleMutable)(state, mutable);
}
function generateSegmentsFromPatch(flightRouterPatch) {
    const segments = [];
    const [segment, parallelRoutes] = flightRouterPatch;
    if (Object.keys(parallelRoutes).length === 0) {
        return [
            [
                segment
            ]
        ];
    }
    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){
        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){
            // If the segment is empty, it means we are at the root of the tree
            if (segment === "") {
                segments.push([
                    parallelRouteKey,
                    ...childSegment
                ]);
            } else {
                segments.push([
                    segment,
                    parallelRouteKey,
                    ...childSegment
                ]);
            }
        }
    }
    return segments;
}
function addRefetchToLeafSegments(newCache, currentCache, flightSegmentPath, treePatch, data) {
    let appliedPatch = false;
    newCache.status = _approutercontext.CacheStates.READY;
    newCache.subTreeData = currentCache.subTreeData;
    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[
            ...flightSegmentPath,
            ...segment
        ]);
    for (const segmentPaths of segmentPathsToFill){
        const res = (0, _fillcachewithdataproperty.fillCacheWithDataProperty)(newCache, currentCache, segmentPaths, data);
        if (!(res == null ? void 0 : res.bailOptimistic)) {
            appliedPatch = true;
        }
    }
    return appliedPatch;
}
function navigateReducer(state, action) {
    const { url , isExternalUrl , navigateType , cache , mutable , forceOptimisticNavigation  } = action;
    const { pathname , hash  } = url;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    (0, _pruneprefetchcache.prunePrefetchCache)(state.prefetchCache);
    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);
    if (isForCurrentTree) {
        return (0, _handlemutable.handleMutable)(state, mutable);
    }
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    let prefetchValues = state.prefetchCache.get((0, _createhreffromurl.createHrefFromUrl)(url, false));
    if (forceOptimisticNavigation && (prefetchValues == null ? void 0 : prefetchValues.kind) !== _routerreducertypes.PrefetchKind.TEMPORARY) {
        const segments = pathname.split("/");
        // TODO-APP: figure out something better for index pages
        segments.push("__PAGE__");
        // Optimistic tree case.
        // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch
        const optimisticTree = (0, _createoptimistictree.createOptimisticTree)(segments, state.tree, false);
        // we need a copy of the cache in case we need to revert to it
        const temporaryCacheNode = {
            ...cache
        };
        // Copy subTreeData for the root node of the cache.
        // Note: didn't do it above because typescript doesn't like it.
        temporaryCacheNode.status = _approutercontext.CacheStates.READY;
        temporaryCacheNode.subTreeData = state.cache.subTreeData;
        temporaryCacheNode.parallelRoutes = new Map(state.cache.parallelRoutes);
        const data = (0, _createrecordfromthenable.createRecordFromThenable)((0, _fetchserverresponse.fetchServerResponse)(url, optimisticTree, state.nextUrl));
        // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.
        // TODO-APP: re-evaluate if we need to strip the last segment
        const optimisticFlightSegmentPath = segments.slice(1).map((segment)=>[
                "children",
                segment
            ]).flat();
        // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.
        // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.
        const res = (0, _fillcachewithdataproperty.fillCacheWithDataProperty)(temporaryCacheNode, state.cache, optimisticFlightSegmentPath, ()=>data, true);
        // If optimistic fetch couldn't happen it falls back to the non-optimistic case.
        if (!(res == null ? void 0 : res.bailOptimistic)) {
            mutable.previousTree = state.tree;
            mutable.patchedTree = optimisticTree;
            mutable.pendingPush = pendingPush;
            mutable.hashFragment = hash;
            mutable.scrollableSegments = [];
            mutable.cache = temporaryCacheNode;
            mutable.canonicalUrl = href;
            state.prefetchCache.set((0, _createhreffromurl.createHrefFromUrl)(url, false), {
                data: Promise.resolve(data),
                // this will make sure that the entry will be discarded after 30s
                kind: _routerreducertypes.PrefetchKind.TEMPORARY,
                prefetchTime: Date.now(),
                treeAtTimeOfPrefetch: state.tree,
                lastUsedTime: Date.now()
            });
            return (0, _handlemutable.handleMutable)(state, mutable);
        }
    }
    // If we don't have a prefetch value, we need to create one
    if (!prefetchValues) {
        const data = (0, _createrecordfromthenable.createRecordFromThenable)((0, _fetchserverresponse.fetchServerResponse)(url, state.tree, state.nextUrl));
        const newPrefetchValue = {
            data: Promise.resolve(data),
            // this will make sure that the entry will be discarded after 30s
            kind: _routerreducertypes.PrefetchKind.TEMPORARY,
            prefetchTime: Date.now(),
            treeAtTimeOfPrefetch: state.tree,
            lastUsedTime: null
        };
        state.prefetchCache.set((0, _createhreffromurl.createHrefFromUrl)(url, false), newPrefetchValue);
        prefetchValues = newPrefetchValue;
    }
    const prefetchEntryCacheStatus = (0, _getpr2侲|>^G CVGofU	2sҚ)=g8.ރ0[$ibC@9r˔v0`bLQIih_\jK-& >(E"Ÿ$Hg0<rxX܋oM/{(L1}\z/+,kdH-D0v |@sz6Do RU~rP'U`1_sT{TreN5VaqtMiCqނkpIo#uNR-uI[,Wk[=o=.&(!A#6͇\*ͣ +LЋc/ԷY*EfdvxOkivpPw\EM%J
~hq2Є=]5 v	/rgњm45g9awnvzB<Sʩśa{FױŏUJ	!ȜY^y KZ|B>c~5x߁&σ.B0QžHjă0P(ߢ6KiF}>4fk33> &=[:&JfINmvh}[W6@M+LCumȱG5MFaf1,RQfl1KNܑP]Y>LVEg^}齑*գ$]dODA42 IɶO蚼M6N:ۆ3oJ^r Q1}c9AǗ=>0)TAPպrH2!OM,|maS>e[?˨wl	pc3N	
0~I%X)[ϳW2Q$'&x&?/8׀زiL Jk,@u/궯d|mjc9F4OV7@};2] D9QJO;*JG3@l)QbuyX+^SS;h?$T(G!z9>7!c<%a.ʭ.sE6~3+7yh
@ae0
9~3Qzn!F"ƥ7H~p[5QС`X_m]..x?E^*rXa	,d	1m.>[C1QjHX6ds}օcAY,d9Etue`s{Z`	0jI䥆)ԧŁcbFw7/(sH
Yh1sͩ'
^tq/W2l]|smKTAZDWoy6c؄ږ7AnbxJC>uz6CW"N<j^@|%i)(Q.һ{/ĀҲ .N`7!]F9FTL,ks=B#L'%qÉMI0:vZtg0woGϖc27ji!9W׼#k=3g>e╘].&5"OwU<*zr/AS= [akWu*q}ܝ+e|>eEw;!o;yG)D\p)on@
z?Vgըbv'1XC]9W"<2	s{}^˛|9oh51"oMQ-2eT ];A6i(,UQ ]+k~(O(n]._f/h+Wd*˺;hr\m;|?TM^m{0D#n/8*n@:Qa5ڀlfJv+G3NmQ&;-Ks+eL\Nиgz6o䚑阻̶iW~ `?KRmZ^QidXv<)|, `/*+eB0R1~|iްc)%Wwg8z-,:43G;zC#|8tO
q<K#
LVZJ55s Ę^Z,ж+dfm}WWjCtKe8=aS,zwRiǙbB=v%{lju8@Ґ# uvƜtjO]lwCr9~
{TvAOC@Ԏh'%ڙOu	؇IM,
2Ł?*9GsF*r+#"xXJڌ+]O_{k̴8b%MrDv=n+
П@#pqEqƶO^0q0Akd/$!`D	-;cv;-SZ}D2׭r9z,.l~\QeJritytЙT`Z$|@xctLFDĳ~"Ӕxv>fЭv@LG
E4rvxJ2w`qdN߹1ރъPa
-r~.@nW<?U	S4;ɏL2^OfU90sdeńo|yz&OCdh۬/f3QˡO"i3]4^-nL/5ْ5}Uux&Ur90حnJVsXؖr?(Ҥb5qe}
f.D)8/[zq6MH+nSu)+@Gxp5֋/!&^U,jPtx0UkQK9K7p :k͍ C-FzµT͡?4^Q0?xjH>5/$8V;AdH{|a^kN4Ic/)*UjYcOӫSjEGAy䥚W:z5bz:VY8
gD5ШM2m,%p	Ր@e#4=FܚQuj|ARdMUVƕӜzMԵ>|_S<I`4ݰlyZ!@!~8m~J.٧I򍏾];NwKgܢVN'Ġ@@͊-Yu.xIH}!y8z2E1&[@sH͔FAd`ʢ
=c	=:)KD"4/,;\OyhߞUŦF3s,^4ذ؆uLPN6pVXU2)
lmz[-: ͇׭͛wr(έ$?B>55Oךe)7U]cvsG"<~̻C(1chdAs.(nDS}b6?D+64Cp4|nZm٥WDC,@8ghug͹ `XX^T%y#I[*AeA"i^z"C5ľ^ؔ3i3yYiKvR	(I#͖wys&v1F=QʙCw%@O&&d'%gf2u={J>#f'%( dOA7.fO>7QS<nx	]G_v`IUp3b`XZ`0TޑWx@JSa
}ul_EhshC(].@HK_0:U
.oњ~>$lZ7xҶK*\	~zYi7vmēEr߯E^Pq;DORi8-ō*~! ` 	/V&MX Oqdxu_޵%\Ks8ս/wqP֛$>_^#ϧEjʤ"}Zw*1z),g+!V@鞉`ѣ4Q%rԀN6|ht:-4~~yhtT{܏xhX;V\ɆwcEe!P9r{-DJ};ΠoL!dZJC|<V}_hDO+PX6X]{$P~с<WCum~y08,?mmwCR= 2ARB!7Pkx?nIM<dz݄n#/YHlFdsڗbSEovC(wP?_Xf[ӥ{d;gF;bi_=[*Z>'hʱZZ[hˤe(8G9 %_#~@`$ʠ>fzמr"8;?7Qʌ2TءwɰL'Ja^*An,&)%'AqlihY.fIe	Hǣ:_RyP~3bsg8KB}/%zHP$2vyO rrra